

-- | Assign left hand side
AssignToIdent . AssignLHS ::= Identifier ;
AssignToArrayElem . AssignLHS ::= ArrayElem ;
AssignToPair . AssignLHS ::= PairElem ;


-- | Assign Right hand side
AssignExp          . AssignRhs ::= Exp ;
AssignArrayLit     . AssignRhs ::= ArrayDeclarationLiteral ;
AssignPair         . AssignRhs ::= "newpair" "(" Exp "," Exp ")" ;
AssignPairElem     . AssignRHS ::= PairElem ;
AssignFunctionCall . AssignRHS ::= "call" Identifier "(" ArgumentList ")" ;


-- | Argument list for function
ArgumentList . ArgumentList ::= [Elem] ;


-- | Pair Element return
PairFst . PairElem ::= "fst" Exp ;
PairSnd . PairElem ::= "snd" Exp ;


-- | Global types
BaseType  . Type ::= BaseType ;
ArrayType . Type ::= ArrayDeclarationLiteral ;
PairType  . Type ::= "pair" "(" PairElemType "," PairElemType ")" ;


-- | Base type
IntType    . BaseType ::= "int" ;
BoolType   . BaseType ::= "bool" ;
CharType   . BaseType ::= "char" ;
StringType . BaseType ::= "string" ;

-- | Array Type Declaration literal
ArrayDeclarationLiteral . ArrayDeclarationLiteral ::= Type "[" "]" ;

ArrayElem        . ArrayElem        ::= Identifier "[" ArrayElemLiteral "]" ;
ArrayElemLiteral . ArrayElemLiteral ::= [Exp] ;
(:[])            . [Exp] ::= Exp ;
(:)							 . [Exp] ::= Exp "," [Exp] ;


-- | Pair Element type
PairElemTypeBase  . PairElemType ::= BaseType ;
PairElemTypeArray . PairElemType ::= ArrayDeclarationLiteral ;
PairElemTypePair  . PairElemType ::= "pair" ;


-- | Expression
IntExp     . Exp ::= IntLiteral ;
BoolExp    . Exp ::= BoolLiteral ;
CharExpr   . Exp ::= CharLiteral ;
StringExpr . Exp ::= StringLiteral ;
PairExpr   . Exp ::= PairLiteral ;
IdentExpr  . Exp ::= Identifier ;
ArrayExpr  . Exp ::= Identifier ArrayAccess;
UExpr      . Exp ::= UnaryOperator Exp ;
BExp       . Exp ::= Exp BinaryOperator Exp ;
BracketExp . Exp ::= "(" Exp ")" ;


-- | Int literal declaration data
IntPlus    . IntLiteral ::= PlusLiteral IntDigit ;
IntMinus   . IntLiteral ::= MinusLiteral IntDigit ;
IntLiteral . IntLiteral ::= IntDigit ;


-- | Array Element structure ()
ArrayAccess . ArrayAccess   ::= "[" Exp "]" ;
(:[])       . [ArrayAccess] ::= ArrayAccess ;
(:)					. [ArrayAccess] ::= ArrayAccess [ArrayAccess] ; 


-- | Operators
UBang   . UnaryOperator ::= "!" ;
UMinus  . UnaryOperator ::= "-" ;
ULenght . UnaryOperator ::= "len" ;
UOrd    . UnaryOperator ::= "ord" ;
UChr    . UnaryOperator ::= "char" ;

BTimes    . BinaryOperator ::= "*" ;
BDivide   . BinaryOperator ::= "/" ;
BModulus  . BinaryOperator ::= "%" ;
BPlus     . BinaryOperator ::= "+" ;
BMinus    . BinaryOperator ::= "-" ;
BMore     . BinaryOperator ::= ">" ;
BLess     . BinaryOperator ::= "<" ;
BMoreEqual. BinaryOperator ::= ">=" ;
BLessEqual. BinaryOperator ::= "<=" ;
BEqual    . BinaryOperator ::= "==" ;
BNotEqual . BinaryOperator ::= "!-" ;
BAnd      . BinaryOperator ::= "&&" ;
BOr       . BinaryOperator ::= "||" ;


-- | Tokens recognition
-- Note the @position@ keyword enables us to keep the position in the ADT tree for clearer 
-- semantic analysis error messages. The pseudo regex language used after
-- TODO see which should be kept as tokens and which should be leftout
position token IntDigit (digit+) ;
position token PlusLiteral ({"+"}) ;
position token MinusLiteral ({"-"}) ;
position token BoolLiteral ({"true"} | {"false"}) ;
position token CharLiteral ('\'' ((char - ["'\\\""]) | ('\\' ["'\\nt"])) '\'') ;
position token PairLiteral ({"null"}) ;
position token Identifier (('_' | lower) (letter | digit | '_')*) ;
position token StringLiteral ('"' ((char - ["'\\\""]) | ('\\' ["'\\nt"]))* '"') ;


-- | Comment parser
comment "#" ;