-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
module ParWacc where
import AbsWacc
import LexWacc
import ErrM

}

%name pExp Exp
%name pProgram Program
%name pFunction Function
%name pListFunction ListFunction
%name pParameter Parameter
%name pListParameter ListParameter
%name pStatement Statement
%name pListStatement ListStatement
%name pAssignLhs AssignLhs
%name pAssignRhs AssignRhs
%name pArgumentList ArgumentList
%name pListArgumentList ListArgumentList
%name pPairElem PairElem
%name pType Type
%name pBaseType BaseType
%name pArrayDeclarationLiteral ArrayDeclarationLiteral
%name pArrayElem ArrayElem
%name pArrayAccess ArrayAccess
%name pListArrayAccess ListArrayAccess
%name pArrayLiteral ArrayLiteral
%name pArrayLiteralElem ArrayLiteralElem
%name pListArrayLiteralElem ListArrayLiteralElem
%name pPairElemType PairElemType
%name pExpression Expression
%name pUnaryOperator UnaryOperator
%name pBinaryOperator BinaryOperator
%name pIntLiteral IntLiteral
-- no lexer declaration
%monad { Err } { thenM } { returnM }
%tokentype {Token}
%token
  ',' { PT _ (TS _ 1) }
  ';' { PT _ (TS _ 2) }

L_EndT { PT _ (T_EndT _) }
L_BeginT { PT _ (T_BeginT _) }
L_SkipT { PT _ (T_SkipT _) }
L_ReadT { PT _ (T_ReadT _) }
L_PrintT { PT _ (T_PrintT _) }
L_PrintLnT { PT _ (T_PrintLnT _) }
L_FreeT { PT _ (T_FreeT _) }
L_ExitT { PT _ (T_ExitT _) }
L_IntDigit { PT _ (T_IntDigit _) }
L_PlusToken { PT _ (T_PlusToken _) }
L_MinusToken { PT _ (T_MinusToken _) }
L_BoolLiteral { PT _ (T_BoolLiteral _) }
L_IntT { PT _ (T_IntT _) }
L_BoolT { PT _ (T_BoolT _) }
L_CharT { PT _ (T_CharT _) }
L_StringT { PT _ (T_StringT _) }
L_TimesT { PT _ (T_TimesT _) }
L_DivideT { PT _ (T_DivideT _) }
L_ModuloT { PT _ (T_ModuloT _) }
L_GreaterT { PT _ (T_GreaterT _) }
L_LessT { PT _ (T_LessT _) }
L_GreaterEqT { PT _ (T_GreaterEqT _) }
L_LessEqT { PT _ (T_LessEqT _) }
L_EqT { PT _ (T_EqT _) }
L_NotEqT { PT _ (T_NotEqT _) }
L_AndT { PT _ (T_AndT _) }
L_OrT { PT _ (T_OrT _) }
L_LParenT { PT _ (T_LParenT _) }
L_RParenT { PT _ (T_RParenT _) }
L_LBracketT { PT _ (T_LBracketT _) }
L_RBracketT { PT _ (T_RBracketT _) }
L_IsT { PT _ (T_IsT _) }
L_WhileT { PT _ (T_WhileT _) }
L_DoT { PT _ (T_DoT _) }
L_DoneT { PT _ (T_DoneT _) }
L_IfT { PT _ (T_IfT _) }
L_FiT { PT _ (T_FiT _) }
L_ThenT { PT _ (T_ThenT _) }
L_ElseT { PT _ (T_ElseT _) }
L_PairT { PT _ (T_PairT _) }
L_NewpairT { PT _ (T_NewpairT _) }
L_CallT { PT _ (T_CallT _) }
L_FstT { PT _ (T_FstT _) }
L_SndT { PT _ (T_SndT _) }
L_EqualT { PT _ (T_EqualT _) }
L_LenT { PT _ (T_LenT _) }
L_OrdT { PT _ (T_OrdT _) }
L_ChrT { PT _ (T_ChrT _) }
L_ReturnT { PT _ (T_ReturnT _) }
L_NotT { PT _ (T_NotT _) }
L_PairLiteral { PT _ (T_PairLiteral _) }
L_CharLiteral { PT _ (T_CharLiteral _) }
L_StringLiteral { PT _ (T_StringLiteral _) }
L_Identifier { PT _ (T_Identifier _) }


%%

EndT    :: { EndT} : L_EndT { EndT (mkPosToken)}
BeginT    :: { BeginT} : L_BeginT { BeginT (mkPosToken)}
SkipT    :: { SkipT} : L_SkipT { SkipT (mkPosToken)}
ReadT    :: { ReadT} : L_ReadT { ReadT (mkPosToken)}
PrintT    :: { PrintT} : L_PrintT { PrintT (mkPosToken)}
PrintLnT    :: { PrintLnT} : L_PrintLnT { PrintLnT (mkPosToken)}
FreeT    :: { FreeT} : L_FreeT { FreeT (mkPosToken)}
ExitT    :: { ExitT} : L_ExitT { ExitT (mkPosToken)}
IntDigit    :: { IntDigit} : L_IntDigit { IntDigit (mkPosToken $1)}
PlusToken    :: { PlusToken} : L_PlusToken { PlusToken (mkPosToken)}
MinusToken    :: { MinusToken} : L_MinusToken { MinusToken (mkPosToken)}
BoolLiteral    :: { BoolLiteral} : L_BoolLiteral { BoolLiteral (mkPosToken $1)}
IntT    :: { IntT} : L_IntT { IntT (mkPosToken)}
BoolT    :: { BoolT} : L_BoolT { BoolT (mkPosToken)}
CharT    :: { CharT} : L_CharT { CharT (mkPosToken)}
StringT    :: { StringT} : L_StringT { StringT (mkPosToken)}
TimesT    :: { TimesT} : L_TimesT { TimesT (mkPosToken)}
DivideT    :: { DivideT} : L_DivideT { DivideT (mkPosToken)}
ModuloT    :: { ModuloT} : L_ModuloT { ModuloT (mkPosToken)}
GreaterT    :: { GreaterT} : L_GreaterT { GreaterT (mkPosToken)}
LessT    :: { LessT} : L_LessT { LessT (mkPosToken)}
GreaterEqT    :: { GreaterEqT} : L_GreaterEqT { GreaterEqT (mkPosToken)}
LessEqT    :: { LessEqT} : L_LessEqT { LessEqT (mkPosToken)}
EqT    :: { EqT} : L_EqT { EqT (mkPosToken)}
NotEqT    :: { NotEqT} : L_NotEqT { NotEqT (mkPosToken)}
AndT    :: { AndT} : L_AndT { AndT (mkPosToken)}
OrT    :: { OrT} : L_OrT { OrT (mkPosToken)}
LParenT    :: { LParenT} : L_LParenT { LParenT (mkPosToken)}
RParenT    :: { RParenT} : L_RParenT { RParenT (mkPosToken)}
LBracketT    :: { LBracketT} : L_LBracketT { LBracketT (mkPosToken)}
RBracketT    :: { RBracketT} : L_RBracketT { RBracketT (mkPosToken)}
IsT    :: { IsT} : L_IsT { IsT (mkPosToken)}
WhileT    :: { WhileT} : L_WhileT { WhileT (mkPosToken)}
DoT    :: { DoT} : L_DoT { DoT (mkPosToken)}
DoneT    :: { DoneT} : L_DoneT { DoneT (mkPosToken)}
IfT    :: { IfT} : L_IfT { IfT (mkPosToken)}
FiT    :: { FiT} : L_FiT { FiT (mkPosToken)}
ThenT    :: { ThenT} : L_ThenT { ThenT (mkPosToken)}
ElseT    :: { ElseT} : L_ElseT { ElseT (mkPosToken)}
PairT    :: { PairT} : L_PairT { PairT (mkPosToken)}
NewpairT    :: { NewpairT} : L_NewpairT { NewpairT (mkPosToken)}
CallT    :: { CallT} : L_CallT { CallT (mkPosToken)}
FstT    :: { FstT} : L_FstT { FstT (mkPosToken)}
SndT    :: { SndT} : L_SndT { SndT (mkPosToken)}
EqualT    :: { EqualT} : L_EqualT { EqualT (mkPosToken)}
LenT    :: { LenT} : L_LenT { LenT (mkPosToken)}
OrdT    :: { OrdT} : L_OrdT { OrdT (mkPosToken)}
ChrT    :: { ChrT} : L_ChrT { ChrT (mkPosToken)}
ReturnT    :: { ReturnT} : L_ReturnT { ReturnT (mkPosToken)}
NotT    :: { NotT} : L_NotT { NotT (mkPosToken)}
PairLiteral    :: { PairLiteral} : L_PairLiteral { PairLiteral (mkPosToken)}
CharLiteral    :: { CharLiteral} : L_CharLiteral { CharLiteral (mkPosToken $1)}
StringLiteral    :: { StringLiteral} : L_StringLiteral { StringLiteral (mkPosToken $1)}
Identifier    :: { Identifier} : L_Identifier { Identifier (mkPosToken $1)}

Exp :: { Exp }
Exp : Program { AbsWacc.WaccTree $1 }
Program :: { Program }
Program : BeginT ListFunction ListStatement EndT { AbsWacc.Program $1 (reverse $2) $3 $4 }
Function :: { Function }
Function : Type Identifier LParenT ListParameter RParenT IsT ListStatement EndT { AbsWacc.Function $1 $2 $3 $4 $5 $6 $7 $8 }
ListFunction :: { [Function] }
ListFunction : {- empty -} { [] }
             | ListFunction Function { flip (:) $1 $2 }
Parameter :: { Parameter }
Parameter : Type Identifier { AbsWacc.Param $1 $2 }
ListParameter :: { [Parameter] }
ListParameter : {- empty -} { [] }
              | Parameter { (:[]) $1 }
              | Parameter ',' ListParameter { (:) $1 $3 }
Statement :: { Statement }
Statement : SkipT { AbsWacc.StatSkip $1 }
          | Type Identifier EqualT AssignRhs { AbsWacc.StatDecAss $1 $2 $3 $4 }
          | AssignLhs EqualT AssignRhs { AbsWacc.StatAss $1 $2 $3 }
          | ReadT AssignLhs { AbsWacc.StatRead $1 $2 }
          | FreeT Expression { AbsWacc.StatFree $1 $2 }
          | ReturnT Expression { AbsWacc.StatReturn $1 $2 }
          | ExitT Expression { AbsWacc.StatExit $1 $2 }
          | PrintT Expression { AbsWacc.StatPrint $1 $2 }
          | PrintLnT Expression { AbsWacc.StatPrintLn $1 $2 }
          | IfT Expression ThenT ListStatement ElseT ListStatement FiT { AbsWacc.StatIf $1 $2 $3 $4 $5 $6 $7 }
          | WhileT Expression DoT ListStatement DoneT { AbsWacc.StatWhile $1 $2 $3 $4 $5 }
          | BeginT ListStatement EndT { AbsWacc.StatScope $1 $2 $3 }
ListStatement :: { [Statement] }
ListStatement : Statement { (:[]) $1 }
              | Statement ';' ListStatement { (:) $1 $3 }
AssignLhs :: { AssignLhs }
AssignLhs : Identifier { AbsWacc.AssignToIdent $1 }
          | ArrayElem { AbsWacc.AssignToArrayElem $1 }
          | PairElem { AbsWacc.AssignToPair $1 }
AssignRhs :: { AssignRhs }
AssignRhs : Expression { AbsWacc.AssignExp $1 }
          | ArrayLiteral { AbsWacc.AssignArrayLit $1 }
          | NewpairT LParenT Expression ',' Expression RParenT { AbsWacc.AssignPair $1 $2 $3 $5 $6 }
          | PairElem { AbsWacc.AssignPairElem $1 }
          | CallT Identifier LParenT ListArgumentList RParenT { AbsWacc.AssignFunctionCall $1 $2 $3 $4 $5 }
ArgumentList :: { ArgumentList }
ArgumentList : Expression { AbsWacc.ArgumentList $1 }
ListArgumentList :: { [ArgumentList] }
ListArgumentList : {- empty -} { [] }
                 | ArgumentList { (:[]) $1 }
                 | ArgumentList ',' ListArgumentList { (:) $1 $3 }
PairElem :: { PairElem }
PairElem : FstT Expression { AbsWacc.PairFst $1 $2 }
         | SndT Expression { AbsWacc.PairSnd $1 $2 }
Type :: { Type }
Type : BaseType { AbsWacc.BaseType $1 }
     | ArrayDeclarationLiteral { AbsWacc.ArrayType $1 }
     | PairT LParenT PairElemType ',' PairElemType RParenT { AbsWacc.PairType $1 $2 $3 $5 $6 }
BaseType :: { BaseType }
BaseType : IntT { AbsWacc.IntType $1 }
         | BoolT { AbsWacc.BoolType $1 }
         | CharT { AbsWacc.CharType $1 }
         | StringT { AbsWacc.StringType $1 }
ArrayDeclarationLiteral :: { ArrayDeclarationLiteral }
ArrayDeclarationLiteral : Type LBracketT RBracketT { AbsWacc.ArrayDeclarationLiteral $1 $2 $3 }
ArrayElem :: { ArrayElem }
ArrayElem : Identifier ListArrayAccess { AbsWacc.ArrayElem $1 $2 }
ArrayAccess :: { ArrayAccess }
ArrayAccess : LBracketT Expression RBracketT { AbsWacc.ArrayAccess $1 $2 $3 }
ListArrayAccess :: { [ArrayAccess] }
ListArrayAccess : ArrayAccess { (:[]) $1 }
                | ArrayAccess ListArrayAccess { (:) $1 $2 }
ArrayLiteral :: { ArrayLiteral }
ArrayLiteral : LBracketT ListArrayLiteralElem RBracketT { AbsWacc.ArrayLiteral $1 $2 $3 }
ArrayLiteralElem :: { ArrayLiteralElem }
ArrayLiteralElem : Expression { AbsWacc.ArrayLiteralElem $1 }
ListArrayLiteralElem :: { [ArrayLiteralElem] }
ListArrayLiteralElem : {- empty -} { [] }
                     | ArrayLiteralElem { (:[]) $1 }
                     | ArrayLiteralElem ',' ListArrayLiteralElem { (:) $1 $3 }
PairElemType :: { PairElemType }
PairElemType : BaseType { AbsWacc.PairElemTypeBase $1 }
             | ArrayDeclarationLiteral { AbsWacc.PairElemTypeArray $1 }
             | PairT { AbsWacc.PairElemTypePair $1 }
Expression :: { Expression }
Expression : IntLiteral { AbsWacc.IntExp $1 }
           | BoolLiteral { AbsWacc.BoolExp $1 }
           | CharLiteral { AbsWacc.CharExpr $1 }
           | StringLiteral { AbsWacc.StringExpr $1 }
           | PairLiteral { AbsWacc.PairExpr $1 }
           | Identifier { AbsWacc.IdentExpr $1 }
           | ArrayElem { AbsWacc.ArrayExpr $1 }
           | UnaryOperator Expression { AbsWacc.UExpr $1 $2 }
           | Expression BinaryOperator Expression { AbsWacc.BExp $1 $2 $3 }
           | LParenT Expression RParenT { AbsWacc.BracketExp $1 $2 $3 }
UnaryOperator :: { UnaryOperator }
UnaryOperator : NotT { AbsWacc.UBang $1 }
              | MinusToken { AbsWacc.UMinus $1 }
              | LenT { AbsWacc.ULength $1 }
              | OrdT { AbsWacc.UOrd $1 }
              | ChrT { AbsWacc.UChr $1 }
BinaryOperator :: { BinaryOperator }
BinaryOperator : TimesT { AbsWacc.BTimes $1 }
               | DivideT { AbsWacc.BDivide $1 }
               | ModuloT { AbsWacc.BModulus $1 }
               | PlusToken { AbsWacc.BPlus $1 }
               | MinusToken { AbsWacc.BMinus $1 }
               | GreaterT { AbsWacc.BGreater $1 }
               | LessT { AbsWacc.BLess $1 }
               | GreaterEqT { AbsWacc.BGreaterEqual $1 }
               | LessEqT { AbsWacc.BLessEqual $1 }
               | EqT { AbsWacc.BEqual $1 }
               | NotEqT { AbsWacc.BNotEqual $1 }
               | AndT { AbsWacc.BAnd $1 }
               | OrT { AbsWacc.BOr $1 }
IntLiteral :: { IntLiteral }
IntLiteral : PlusToken IntDigit { AbsWacc.IntPlus $1 $2 }
           | MinusToken IntDigit { AbsWacc.IntMinus $1 $2 }
           | IntDigit { AbsWacc.IntLiteral $1 }
{

returnM :: a -> Err a
returnM = return

thenM :: Err a -> (a -> Err b) -> Err b
thenM = (>>=)

happyError :: [Token] -> Err a
happyError ts =
  Bad $ "syntax error at " ++ tokenPos ts ++ 
  case ts of
    [] -> []
    [Err _] -> " due to lexer error"
    _ -> " before " ++ unwords (map (id . prToken) (take 4 ts))

myLexer = tokens
}

